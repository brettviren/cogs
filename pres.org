* schema

schema is a data structure

which may be interpreted 

as describing the structure of data

(including that of schema)

* Categories of schema interpretation

- translating :: ~interpret(schema)~ $\to$ ~schema~
- generating :: ~interpret(schema)~ $\to$ data
- validating :: ~interpret(schema, data)~ $\to$ /true/ | /false/

* requirements

- well structured configuration information (object schema)
- developers define structure their code needs
- deliver configuration object to application (serialization)
- automate object parsing and validation 
- anticipate needs of appfmk and non-appfmk apps
- low software dependencies

* configuration stream

A configuration is delivered as an ordered sequence of objects (stream).

#+begin_src c++
  std::string uri = "....";
  stream_p s = cogs::make_stream(uri);
  cogs::object o = s->pop();
#+end_src

The ~make_stream()~ factory returns steam based on parsing URI.

The returned ~unique_ptr<cogs::Stream>~ is abstract.

Exceptions defined by ERS may be thrown.

* stream types

URI batteries included:

- ~file://config.json~ :: a JSON array of configuration objects
- ~file://config.jstream~ :: A [[https://en.wikipedia.org/wiki/JSON_streaming][JSON Stream]] of configuration objects

Potential future stream types URIs:

- ZeroMQ/ZIO port spec (auto-discovery)
- RPC server address (hardwired) 

* apply configuration

An application component receives configuration object through a *virtual mixin* class inheritance:

** A *typeless* interface 

The ~cogs::object~ is type ~nlohmann::json~.

#+begin_src c++
struct ConfigurableBase {
    virtual void configure(object obj) = 0;
};
#+end_src

** A *fully typed* interface

The template type is the components C++ ~struct~ holding config info

#+begin_src c++
template<class CfgObj>
struct Configurable : virtual public ConfigurableBase {
    virtual void configure(CfgObj&& cfgobj) = 0;
};
#+end_src

* Object Serialization

Configuration info passes through at least these life cycle stages:

- bytes in a stream following valid structure
- type free ~cogs::object~ in memory
- full C++ ~struct~ type specific to component (~MyCfgObj~)

Every type of ~MyCfgObj~ is a C++ struct that is *generated* based on
developer-provided *schema*.

* Schema

A *schema* is *structured data* that describes the *structure of other data*.

For cogs, we may provide schema in many languages:

- python :: ~dict~, ~list~, ~str~, ~int~, ~float~, ~bool~
- JSON :: object, array, string, number, Boolean
- Jsonnet :: ~record()~, ~sequence()~, ~string()~, ~number()~, ~boolean()~

Given a schema, we may:

- facilitate creation of configuration objects

- validate created configuration objects

- generate code to operate on valid objects

* Schema technology

~cogs~ selects:

- authoring :: [[https://jsonnet.org/][Jsonnet]]
- validation :: [[http://json-schema.org/][JSON Schema]]
- generation :: [[https://avro.apache.org/][Avro Schema]] (may revisit)
- tooling :: [[https://github.com/brettviren/moo][moo]]

* Authoring 

~cogs~ recommends authoring schema in Jsonnet language

- simple, easy to learn configuration language
- existing nearby packages use it (PTMP, Wire-Cell)
- super-set of JSON but not as painful for humans to write and read
- pure-functional, LISP-esque language gives just enough power

With ~moo~ we may write generalize schema in Jsonnet which we may *compile* to useful forms:

- JSON Schema for validation
- Avro Schema for code generation
- (possible future) SQL for table creation, etc

* Example Schema

#+begin_src jsonnet
  local node = s.record("Node", fields=[
      s.field("ident", ident,
              doc="Idenfity the node instance"),
      s.field("portdefs", s.sequence("Port"), 
              doc="Define ports on the node to be used by components"),
      s.field("compdefs", s.sequence("Comp"),
              doc="Define components the node should instantiate and configure"),
  ], doc="A node configures ports and components"),
#+end_src

* Validating

JSON Schema

* Code Generation

Avro Schema

* Creating streams

