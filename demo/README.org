#+title: cogs demo

This directory holds an example of using cogs.  It includes:

- A mocked up framework, application and components.
- Schema to generate configuration classes.
- Example cogs configuration stream file.

* Prerequisites:

Generating code for the demo is currently not automated into a build.
Generated files are committed and may be regenerated by doing:

#+begin_example
  $ cd demo
  $ ./generate.sh
#+end_example

This script requires:

- ~avrogencpp~ :: the Avro generator for C++
- ~moo~ :: [[https://github.com/brettviren/moo]]

* Running the demo

Building ~cogs~ should also build the program ~cogs-demo~ 

#+begin_example
  $ ./build/demo/cogs-demo file://demo/demo-config.json
#+end_example

The output printed will show the configuration driving the
construction of a node and a "source" component followed by their
configuration.  When the node is configured it makes a (dummy) port
and hands it to the "source" which it looks up by type and name.

* Demo framework

It is possible to use cogs in a variety of patterns.  This demo
illustrates one particular pattern, such as may be used in an
"application framework" where the configuration drives the aggregation
of dynamically provided components into a working application.  This
pattern provides for a highly flexible system but of course other
patterns may be employed with ~cogs~.

** Demo configuration stream

At top-level (inside ~main()~) it only knows about a ~cogs::Stream~ and
~demo::ConfigurableBase~ objects.  The configuration stream is assumed
to provide ordered pairs of configuration objects:

|--------------------------|
| ~democfg::ConfigHeader~    |
|--------------------------|
| corresponding cfg object |
|--------------------------|
| ...                      |
|--------------------------|
| ~democfg::ConfigHeader~    |
|--------------------------|
| corresponding cfg object |
|--------------------------|

** Dispatching configuration

The ~ConfigHeader~ provides two attributes:

- implementation identifier :: this is some name associated with a
  construction method for an implementation of ~ConfigurableBase~.  This
  identifier is some simple name, likely derived from the component's
  C++ class name.

- instance identifier :: multiple instances of one component may be
  constructed and this identifier keeps then distinct.

The main application walks the ~cogs::Stream~ using the ~ConfigHeader~ to
retrieve an instance from the demo factory.  It then reads the next
object from the ~cogs::Stream~ and passes it to the component's
~configure()~ method.  When the stream is exhausted the demo app simply
exits.  A real app would of course go on to some other phase of
execution.

** Non-trivial application patterns

The demo adds some non-trivial complexity by considering two types of
configurable objects:

- node :: an object which has a collection of /ports/ such may be
  associated with sockets.  The demo keeps ports as dummies but they
  represent some shared resource that is non-trivial to construct.

- components :: an object which is configurable and may also want to
  use /ports/.  There is only a single component in the demo called a
  "source".  It represents some arbitrary "code execution unit" aka
  "user module".

The demo allows configuration of a *node* to interact with *components* so
that any ports requested by the component may be delivered.  This is
done via the factory.  A component must inherit from
~demo::PortuserBase~ and be listed in the node's configuration in order
to receive its ports.



* Code generation

The ~generate.sh~ summarizes the code generation commands.  They would
likely be integrated into a build system.  The script demonstrates
three main parts:

1. Generate C++ ~struct~ for configuration objects with Avro.
2. Generate serialization methods between instances of these ~struct~ and ~nlohmann::json~ objects.
3. Validate and generate an example application configuration

** C++ configuration ~struct~ 

User code should not validate configuration structure so the main
thing ~cogs~ provides is safe "retyping" from the configuration byte
stream to C++ types.  This demo makes use of Avro to generate C++
~struct~ based on schema and defines that schema using ~moo~.

The file [[file://demo-avro.jsonnet][demo-avro.jsonnet]] defines a number of JSON files to be
compiled.  

#+begin_example
  $ moo compile -m . demo-avro.jsonnet
  $ ls -l *_avro.json
#+end_example

Each can be compiled into C++ header files with ~avrogencpp~.

#+begin_example
  $ avrogencpp -n democfg -i node_avro.json -o node_avro.hpp
#+end_example

Note, we must give the C++ namespace on this command line.

Future work may revisit the use of Avro in favor of directly rendering
to C++ as we do not make use of Avro serialization.

** Re-typing / Deserialization

We deserialize from JSON to C++ using support provided by
~nlohmann::json~ by generating ~to_json()~ and ~from_json()~ functions for
each ~struct~.

#+begin_center
  $ moo render-many demo-render.jsonnet
#+end_center

The file [[file::demo-render.jsonnet][demo-render.jsonnet]] collects information for all
configuration classes in the demo.  For each, three things are
provided: a "model" (the schema plus extra info describing the code),
a "template" file to which the model is applied and an output file
name.

** Generate example configuration stream

We finally generate an example ~cogs~ configuration stream in the form
of a JSON file holding an array.  This file is created from Jsonnet by
~moo~:

#+begin_example
  moo compile -D model demo-config.jsonnet > demo-config.json
#+end_example


* A look at the schema

We will focus on the "node" schema.  A node is configured with a list
of port definition objects and component definition objects, each with
some structure.

** Compiling schema with base schema

The node schema is defined in the file [[file::node-schema.jsonnet][node-schema.jsonnet]].  This file
produces a single function taking an argument ~schema~.  This argument
provides "base class methods" which ~node-schema.jsonnet~ uses to
express node-specific schema.  The ~schema~ argument may be supplied to
generate different vocabulary.  In particular the structure provided by 
[[file:avro-schema.jsonnet][avro-schema.jsonnet]] may be "passed in":

#+begin_center
  $ moo compile --tla schema=demo/avro-schema.jsonnet demo/node-schema.jsonnet
  ... big Avro schema text ...
#+end_center

This produces Avro schema (we produced this in part above when
processing ~demo-avro.jsonet~).  We could also produce JSON Schema from
the same source:

#+begin_example
  $ moo compile --tla schema=demo/json-schema.jsonnet demo/node-schema.jsonnet
  ... big JSON Schema text ...
#+end_example

FIXME: Work is ongoing to make use of JSON Schema to validate
configuration objects.

** Developing schema

The main thing a developer wanting configuration must do is define the
structure of that configuration.  The developer provides a function
taking a base schema:

#+begin_src jsonnet
function(schema) {
    // defines types
    types: [ typeA, typeB, ...]
}
#+end_src

It is the attribute ~types~ that is used for codegen.  Additional
attributes can be defined or ~local~ variables may be used in
constructing the types.

*** Strings

A string schema may simply state that a string is to be used or
patterns (regex) can be specified and they can be used for validation.
The demo defies several.

#+begin_src jsonnet
local re = import "re.jsonnet";
function(schema) {
    local ident = schema.string(pattern=re.ident_only),
    local address = schema.string(pattern=re.uri),
    // ...
}
#+end_src

Eg, in ~re.jsonnet~

#+begin_src jsonnet
{
    ident: '[a-zA-Z][a-zA-Z0-9_]*',
    // ...
}
#+end_src

Next in ~node-schema.jsonnet~ we find an ~enum~ defined as an array of
string literals.  Avro translates this into a C++ ~enum class~.

The workhorse is ~record~ which Avro translates to a ~struct~.  A ~record~
has a ~name~ which serves to identify the type that the record defines
and which becomes the name of the ~struct~ in C++.  A record has a
sequence of ~field~ which also has a name and a type.  This type can be
fundamental (eg a ~string~ schema) or a record or enum name.  

Finally there is of course a ~sequence~ of a type which Avro translates
to C++ as a ~std::vector<type>~.




